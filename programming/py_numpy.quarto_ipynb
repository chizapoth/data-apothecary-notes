{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Cheatsheet: NumPy, Pandas Series\"\n",
        "description: |\n",
        "  Refer to the jupyter notebook for rendered code.\n",
        "author: \"Chi Zhang\"\n",
        "date: \"2025-01-22\"\n",
        "categories: [Python]\n",
        "sidebar: false\n",
        "code-block-bg: true\n",
        "code-block-border-left: true\n",
        "jupyter: python3\n",
        "format: \n",
        "  html:\n",
        "    toc: true\n",
        "    toc-depth: 3\n",
        "    code-fold: false\n",
        "    code-tools: false\n",
        "    code-annotations: select\n",
        "---\n",
        "\n",
        "> Resources: [Python Data Science Handbook](https://jakevdp.github.io/PythonDataScienceHandbook/) by Jake VanderPlas\n",
        "\n",
        "::: {.callout-note}\n",
        "\n",
        "Content for **Pandas DataFrame** are in a separate section as it is a very big topic. The data structures here are \n",
        "\n",
        "* Lists\n",
        "* Numpy Array (1D, higher-D)\n",
        "* Pandas Series\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "## Generate data\n",
        "\n",
        "### List sequence \n",
        "\n",
        "Create a list with `range()`\n",
        "\n",
        "```python\n",
        "# create a list directly\n",
        "[1, 2, 3]\n",
        "\n",
        "# the following does not print out the lists\n",
        "range(3)\n",
        "range(0, 10, 2)\n",
        "```\n",
        "\n",
        "There are a few ways to **print out elements** from a list generated from `range()`\n",
        "  * list comprehension (`[function(i) for i in LIST]`)\n",
        "  * directly listing out (`list(LIST)`)\n",
        "  * for loop, more tedious and requires a placeholder to be created first.\n",
        "\n",
        "\n",
        "```python\n",
        "# directly listing out\n",
        "list(range(0, 10, 2))\n",
        "\n",
        "# list comprehension\n",
        "[i for i in range(0, 10, 2)] # omit the function\n",
        "\n",
        "# for loop\n",
        "lst = []\n",
        "for i in range(0, 10, 2):\n",
        "    lst.append(i)\n",
        "```\n",
        "\n",
        "\n",
        "### np.array, sequences with `np.arange()`\n",
        "\n",
        "Distinguish list and array, the way they are created. `range()` is built-in, and produces a **list**. `np.arange()` is from numpy, and produces a **numpy array**. The arguments are the same: `np.arange(start, end, step)`\n",
        "\n",
        "```python\n",
        "import numpy as np\n",
        "np.arange(3)\n",
        "np.arange(0, 10, 2)\n",
        "```\n",
        "\n",
        "Other useful functions to generate a sequence:\n",
        "\n",
        "```python\n",
        "# np.linspace(start, end, nelements)\n",
        "np.linspace(0, 1, 5) # 0, 0.25, 0.5, 0.75, 1\n",
        "\n",
        "# repeat the same values\n",
        "np.zeros(10)\n",
        "np.ones(5)\n",
        "```\n",
        "\n",
        "\n",
        "### Random number `np.random`\n",
        "\n",
        "* Uniform (between 0, 1): `np.random.random((nrow, ncol))`\n",
        "* Normal: `np.random.normal(mu, sd, (nrow, ncol))`\n",
        "* Random integer: `np.random.randint(0, 10, (nrow, ncol))`\n",
        "\n",
        "\n",
        "### Pandas Series\n",
        "\n",
        "A pandas Series is a column variable, rather than a vector. It is similar to a dataframe with one column, hence they have row names (index).\n",
        "\n",
        "Inherently Series is an array. Can change the index\n",
        "\n",
        "```python\n",
        "data = pd.Series([0.25, 0.5, 0.75, 1.0])\n",
        "# access value\n",
        "data.values\n",
        "\n",
        "# customize the index\n",
        "data2 = pd.Series([0.25, 0.5, 0.75, 1.0],\n",
        "                  index = ['a', 'b', 'c', 'd'])\n",
        "data2['a']\n",
        "```\n",
        "\n",
        "Series is also a **dictionary**, so it can be created as such\n",
        "\n",
        "```python\n",
        "my_dict = {'a': 100,\n",
        "           'b': 200,\n",
        "           'c': 300}\n",
        "my_dict = pd.Series(my_dict)\n",
        "```\n",
        "\n",
        "\n",
        "## Common attributes\n",
        "\n",
        "That can be accessed by calling `obj.size`, `obj.value` etc\n",
        "Size, dimension\n",
        "\n",
        ".value\n",
        "\n",
        ".index\n",
        "\n",
        "for dataframe, .column\n",
        "\n",
        "## Computation \n",
        "\n",
        "**Axis**: The axis is quite convenient: `axis = 0` conducts column-wise computations, and `axis = 1` is row-wise. This needs to be distinguished with R where the first axis is row (`apply(matrix, 1, function)` does operation per row).\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Selection\n",
        "\n",
        "Generally counting starts from 0, access the index with square brackets.\n",
        "\n",
        "* indexing: generally refer to column\n",
        "* **slicing**: refer to row\n",
        "* concatenate and splitting\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "### Numpy array\n",
        "\n",
        "#### selection\n",
        "\n",
        "1-D array\n",
        "\n",
        "```python\n",
        "x = np.array([1,2,3,4,5])\n",
        "x[0] # first\n",
        "x[-1] # last\n",
        "x[:4] # slicing\n",
        "x[::2] # every other element\n",
        "x[::-1] # reversing the array\n",
        "```\n",
        "\n",
        "Higher-D array"
      ],
      "id": "da8a30d7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "rng = np.random.RandomState(42)\n",
        "x = rng.randint(0, 10, (3, 4))\n",
        "print(x)\n",
        "print(x[0, 0]) # rowid, colid\n",
        "print(x[0, :]) # entire row: slicing\n",
        "print(x[0]) # entire row\n",
        "print(x[:2, :3])"
      ],
      "id": "1bb8c995",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Indexing\n",
        "\n",
        "Always pay attention to where the index starts, typically 0."
      ],
      "id": "f886ac52"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = np.arange(0, 10) # sequence from 1 to 10\n",
        "ind = [3, 7, 2]\n",
        "x[ind]"
      ],
      "id": "4c294c82",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### concatenate and splitting\n",
        "\n",
        "1-D arrays\n",
        "\n",
        "```python\n",
        "x = np.array([1,2,3])\n",
        "y = np.array([4,5,6])\n",
        "np.concatenate([x, y]) # the square brackets remains\n",
        "```\n",
        "\n",
        "Spliting "
      ],
      "id": "dba270d0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = np.arange(10)\n",
        "x1, x2, x3 = np.split(x, [2, 4])\n",
        "print(x1, x2, x3)"
      ],
      "id": "43e3a9af",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Higher-D arrays\n",
        "\n",
        "```python\n",
        "grid = np.array([[1,2,3],\n",
        "                [4,5,6]])\n",
        "\n",
        "# concatenate, by default is axis=0         \n",
        "np.concatenate([grid, grid])\n",
        "\n",
        "# by column, result is 4 by 3\n",
        "np.concatenate([grid, grid], axis = 0)\n",
        "# by row, result is 2 by 6\n",
        "np.concatenate([grid, grid], axis = 1)\n",
        "\n",
        "# vstack, hstack\n",
        "np.vstack([x, grid])\n",
        "```\n",
        "\n",
        "\n",
        "### Pandas Series\n",
        "\n",
        "#### Indexing\n",
        "\n",
        "Pandas indices are customizable. It is useful to check them. `data.index`\n",
        "\n",
        "If a data has explicit index, can also access the element with index names\n",
        "\n",
        "```python\n",
        "data = pd.Series([0.25, 0.5, 0.75, 1.0])\n",
        "# it is like a 1-d array\n",
        "data[0]\n",
        "\n",
        "data2 = pd.Series([0.25, 0.5, 0.75, 1.0],\n",
        "                  index = ['a', 'b', 'c', 'd'])\n",
        "data2['a']\n",
        "```\n",
        "\n",
        "Difference between `loc` and `iloc`\n",
        "\n",
        "* `loc` refers to the index user defined, typically starts from 1.\n",
        "* `iloc` refers to the implicit python index, starting from 0."
      ],
      "id": "cb17a486"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pandas as pd\n",
        "\n",
        "data = pd.Series(['a', 'b', 'c'], index = [1,3,5])\n",
        "\n",
        "# loc\n",
        "print(data.loc[1])\n",
        "print(data.loc[1:3])\n",
        "\n",
        "# iloc: implicit python style index\n",
        "print(data.iloc[1]) # 2nd\n",
        "print(data.iloc[1:3]) # 2,3rd"
      ],
      "id": "f5a0684d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Missing value for array and pd.series\n",
        "\n",
        "Both `None` and `np.nan` are null.\n",
        " \n",
        "Detect null values with `isnull(), notnull()`\n"
      ],
      "id": "26ff7424"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/chizhang/.pyenv/versions/3.12.7/envs/mypydev312/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}